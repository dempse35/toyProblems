// Given a string and an array of strings, return true if the string exists in the array, and false if it does not.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// str:
// "x"
// array:
// [ "a", "x", "c" ]	true
// str:
// "x"
// array:
// [ "a", "b", "c" ]	false

const searchString = () => {
  //todo
};

// Given a divider number and an array of numbers, return true if the array contains a non-zero number evenly divisible by the divider, and false otherwise.

// DO NOT use array.find()

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// divider:
// 5
// array:
// [ 8, 10 ]	true
// divider:
// 5
// array:
// [ 8, 11 ]	false

const findDivisible = () => {
  //todo
};

// Given a name (string) and an array of people (objects), find the person with the given name and return his/her hobby. Return false if there is no person with the given name.

// DO NOT use people.find()

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// name:
// "Alice"
// people:
// [ { "name": "Alice", "hobby": "programming" }, { "name": "Bob", "hobby": "gaming" } ]	"programming"
const findPerson = () => {
  //todo
};

// Given a length (number) and an array of strings, return all strings that are greater than or equal to the given length.

// DO NOT use .filter() in your solution.

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// length:
// 3
// array:
// [ "a", "ab", "abc", "abcd" ]	[ "abc", "abcd" ]
// length:
// 2
// array:
// [ "x", "hello", "z" ]	[ "hello" ]

const filterLength = () => {
  //todo
};

// Given an array of numbers, return all even numbers from the array.

// DO NOT use .filter() in your solution.

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// numbers:
// [ 10, 20, 25, 30 ]	[ 10, 20, 30 ]

const findEven = () => {
  //todo
};

// Given an array of players (objects), return the names of all players that have a score above 100.

// DO NOT use .filter() in your solution.

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// players:
// [ { "name": "Alice", "score": 88 }, { "name": "Bob", "score": 120 } ]	[ "Bob" ]

const topPlayers = () => {
  //todo
};

// Given an array of numbers, return the sum of those numbers.

// DO NOT use numbers.reduce()

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// numbers:
// [ 10, 20, 30 ]	60
// numbers:
// [ ]	0
const sum = () => {
  //todo
};

// Given an array of strings, return all strings concatenated together.

// DO NOT use strings.reduce() or strings.join('')

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// Examples
// Input	Output
// strings:
// [ "a", "b", "c" ]	"abc"
// strings:
// [ ]	""
const concatStrings = () => {
  //todo
};
// Given an array of arrays, return those arrays concatenated together.

// DO NOT use arrays.reduce() or Function.prototype.apply

// DO use a for loop.

// TRY solving it with non-mutative recursion, only after you’ve solved it using a for loop.

// You've got Helpers! (click to view code)
// constraints
// Examples
// Input	Output
// arrays:
// [ [ 10, 20 ], [ 30 ], [ ] ]	[ 10, 20, 30 ]
// arrays:
// [ [ 22 ], [ 33, [ 44 ] ], [ 55 ] ]	[ 22, 33, [ 44 ], 55 ]
// arrays:
// [ ]	[ ]
const concatArrays = () => {
  //todo
};
